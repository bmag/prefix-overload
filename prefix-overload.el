;;; prefix-overload.el --- Bind several commands to the same key

;; Copyright (C) 2015 Bar Magal

;; Author: Bar Magal (2015)
;; Version: 0.1
;; Homepage: https://github.com/bmag/prefix-overload
;; Package-Requires: ((cl-lib "0.5"))

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; Bind several commands to the same key (overloading).  The correct
;; command is chosen by considering the prefix argument.
;;
;; For example, this binds `ido-switch-buffer' and
;; `ido-switch-buffer-other-window' to [C-x b]:
;;    (define-prefix-overload switch-buffer-overload
;;      '(ido-switch-buffer ido-switch-buffer-other-window))
;;    (define-key purpose-mode-map (kbd "C-x b")
;;      #'switch-buffer-overload)
;; To call `ido-switch-buffer', press [C-x b].  To call
;; `ido-switch-buffer-other-window', press [C-u C-x b].

;;; Code:

(require 'cl-lib)

(defun prefix-overload--prefix-arg-to-index (prefix-argument)
  "Turn prefix argument PREFIX-ARGUMENT to a logical index.
Examples:
\\[universal-argument] <command>: index 1
\\[universal-argument] \\[universal-argument] <command>: index 2
\\[universal-argument] 2 <command>: index 2
\\[universal-argument] 1 2 <command>: index 12
<command>: index 0 (no prefix argument used)"
  (cond
   ((null prefix-argument)
    0)
	
   ((listp prefix-argument)
    (round (log (car prefix-argument) 4)))

   ((eq prefix-argument '-)
    -1)
   
   (t
    prefix-argument)))

(defun prefix-overload--generate-documentation (name commands)
  (let ((doc-first (format "\\[%s]: `%s'" name (car commands)))
	(doc-rest
	 (cl-loop for c in (cdr commands)
		  for i from 1
		  collect (format "%s \\[%s], \\[universal-argument] %s \\[%s]: `%s'"
				  (mapconcat #'identity
					     (cl-loop for j from 1 to i
						      collect "\\[universal-argument]")
					     " ")
				  name
				  i
				  name
				  c))))
    (mapconcat
     #'identity
     (append
      (list "This function was generated by `define-prefix-overload'."
	    ""
	    doc-first)
      doc-rest)
     "\n")))

;;;###autoload
(defmacro define-prefix-overload (name commands)
  "Define an interactive function named NAME, which calls interactively
one command from COMMANDS.
The command is chosen by the prefix argument:
no prefix argument: first command;
\\[universal-argument] or \\[universal-argument] 1: second command;
\\[universal-argument] \\[universal-argument] or \\[universal-argument] 2: third command;
and so on.
Use it like this:
   (define-prefix-overload hello '(command1 command2 command3))"
  (unless (eval commands)
    (error "Argument COMMANDS cannot be empty"))
  `(defun ,name (&optional arg)
     ,(prefix-overload--generate-documentation name (eval commands))
     (interactive "P")
     (let* ((index (prefix-overload--prefix-arg-to-index arg))
	    (command (nth index ,commands)))
       (if command
	   (call-interactively command)
	 (error "Index %s too big" index)))))

(provide 'prefix-overload)
;;; prefix-overload.el ends here
